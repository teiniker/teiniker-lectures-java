# Java Virtual Machine (JVM)

The **java** launcher tool then runs your application with an instance of the Java Virtual Machine.


## Java Class Loaders

With the Java language, the classes generated by the compiler generally remain just as they 
are until they are loading into a JVM. 
Linking classes is part of the job performed by the JVM when it loads them into memory -
**late binding**.

**The runtime system loads classes when they are needed.** 
Each class that gets loaded may have other classes that it depends on, so the loading 
process is recursive.
Once a class is loaded into a JVM, the same class will not be loaded again.

Each class loader also keeps a reference to a parent class loader, defining a 
**tree of class loaders** with the bootstrap loader at the root.

* **Bootstrap class loader**: The bootstrap class loader is used by the JVM to load 
    those Java classes that are necessary for the JVM to function (`java.lang.*` and `java.io.*`). 
* **Extension class loader**: Java 1.2 introduced the standard extension mechanism 
    using the `<JDK>\lib\ext` directory.
    In Java 9 and later the extension mechanism has been removed. 
    This change is part of the **Java Platform Module System (JPMS)** introduced in Java 9.
* **System class loader**: The system class loader locates its classes in those 
    directories and JAR files specified in the **CLASSPATH** environment variable or 
    passed to it via the `-classpath` command line option.
    The system class loader is sometimes called the application class loader.

![Java Class Loader](figures/JavaClassloader.png)

The JVM knows which class loader to use by utilizing the **delegation model**. 
Whenever a class loader receives a request to load a class, it first asks its parent 
to fulfill the request (it delegates the request to the parent class loader). 
If the parent is successful in loading the class, then the resulting class object is 
returned so that it may be instantiated.

Only if a class loader's parent (and its parent, and so on) fails to load the class 
does the original class loader attempt to load the class.
If the class doesn't exist in the bootstrap class loader's domain, then the extension 
class loader will check the standard extensions location for the class. 
If it's still not found, then the system class loader will check the locations specified 
by the `CLASSPATH` variable for the class. If the class still cannot be located, then a 
`ClassNotFoundException`` will be thrown.

Setting the parameter `-verbose:class` on the Java command line prints a trace of 
the class loading process.


## Just In Time Compiler

The Java compiler `javac` takes the high-level sources and converts them into class files 
used by the JVM. So, the JVM always starts with the bytecode representation of the original 
program.

All code starts out initially running in the interpreter, and once it becomes hot enough it 
gets scheduled for **compilation to native code**. In the **HotSpot VM** this is controlled 
through the use of counters associated with each method.
When a compilation is requested, it is enqueued in a list that is monitored by one or more 
compiler threads. 
If a compiler thread is not busy it removes the compilation request from the queue and begins 
to compile it. 


## Memory Segmentation

The Java virtual machine defines various runtime data areas that are used during execution 
of a program. 

![Java Memory Layout](figures/JavaMemoryLayout.png)

* **Program Counter**: The Java virtual machine can support many threads of execution at once. 
    Each Java virtual machine thread has its own pc (program counter) register.

* **Java Virtual Machine Stacks**: Each Java virtual machine thread has a private Java virtual 
    machine stack, created at the same time as the thread. A Java virtual machine stack stores 
    frames containing the operand stack and local variables.

* **Heap**: The heap is shared among all Java virtual machine threads. The heap is the runtime 
    data area from which memory for all class instances and arrays is allocated.
    
* **Method Area**: The Java virtual machine has a method area that is shared among all Java 
    virtual machine threads containing the bytecode and constant pool. 
    
* **Runtime Constant Pool**: It contains several kinds of constants, ranging from numeric literals 
    known at compile time to method and field references that must be resolved at run time.


## VM Garbage Collectors
The JVM specification dictates that any JVM implementation must include a garbage 
collector to reclaim unused memory.

The HotSpot VM uses a **generational garbage collector** that relies on the following 
two observations, known as the **weak generational hypothesis**:
* Most allocated objects become unreachable quickly.
* Few references from older to younger objects exists.

The HotSpot VM splits the heap into spaces (physical areas) which are referred to as generations:

![Heap Memory Generations](figures/JavaMemoryGenerations.png)

* **The young generation**: Most newly allocated objects are allocated in the young generation, 
    which is typically small and collected frequently (minor garbage collection).

* **The old generation**: Objects that are longer-lived are eventually promoted to the old 
    generation. This generation is typically larger than the young generation, and its occupancy 
    grows more slowly. 
    Old generation collections (major garbage collection) are infrequent, but when they do occur, 
    they can be quite lengthy. 

A big advantage of the generational garbage collection is that each generation can 
be managed by the garbage collection algorithm most appropriate for its characteristics.


Since Java 8, the **Metaspace** is used to store class metadata required by the Java 
Virtual Machine (JVM). This change was introduced to improve performance and eliminate 
the need for a fixed size memory area.
The Metaspace replaces the PermGen (**Permanent Generation**).

By default, class metadata allocation is only limited by the  amount of available 
native memory. Use the new flag `MaxMetaspaceSize` to limit the amount of  native 
memory used for class metadata. 


## Java Platform Module System (JPMS)

Java 9 introduces a new level of abstraction above packages, known as the Java Platform 
Module System (JPMS).

**A Module is a group of closely related packages and resources along with a new module 
descriptor file. It's a “package of Java Packages” abstraction**.

The code is organized internally in packages which are used to determine what code is 
publicly accessible outside of the module.
With modules, we can also ship resources like images and XML files with the module that 
needs it.

There are four Types of Modules:

* **System Modules**: These are the modules included in the Java SE and JDK:  
    ```
    $ java --list-modules
    ```

* **Application Modules**: These modules are what we usually want to build when 
    we decide to use Modules. They are named and defined in the compiled `module-info.class` 
    file included in the assembled JAR.

* **Automatic Modules**: We can include unofficial modules by adding existing JAR files 
    to the module path. The name of the module will be derived from the name of the JAR. 
    Automatic modules will have full read access to every other module loaded by the path.

* **Unnamed Modules**: When a class or JAR is loaded onto the `CLASSPATH`, but not the module 
    path, it's automatically added to the unnamed module. It's a catch-all module to maintain 
    backward compatibility with previously-written Java code.

_Example_: Module **java.se** defines the [API of Java SE](https://docs.oracle.com/en/java/javase/21/docs/api/index.html)

![Java SE Modules](figures/JavaSEModules.png)

Modules can be distributed one of two ways: 
* As a JAR file 
* As an _exploded_ compiled project

A multi-module project can be created by combining a main application and 
several library modules.

**There can only be one module per JAR file**.
When setting up a build file, we need to make sure to bundle each module in 
our project as a separate JAR.



## References

* [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
* [Baeldung: Class Loaders in Java](https://www.baeldung.com/java-classloaders)

*Egon Teiniker, 2024, GPL v3.0*
